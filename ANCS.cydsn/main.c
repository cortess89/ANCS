/*******************************************************************************
* File Name: main.c
*
* Version: 1.0
*
* Description:
*  This is the source code for the Apple Notification Center Services project.
*
* Hardware Dependency:
*  CY8CKIT-042-BLE
*
********************************************************************************
* Copyright (2015), Cypress Semiconductor Corporation.
******************************************************************************
* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
* protected by and subject to worldwide patent protection (United States and
* foreign), United States copyright laws and international treaty provisions.
* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
* license to copy, use, modify, create derivative works of, and compile the
* Cypress Source Code and derivative works for the sole purpose of creating
* custom software in support of licensee product to be used only in conjunction
* with a Cypress integrated circuit as specified in the applicable agreement.
* Any reproduction, modification, translation, compilation, or representation of
* this software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
* Cypress reserves the right to make changes without further notice to the
* materials described herein. Cypress does not assume any liability arising out
* of the application or use of any product or circuit described herein. Cypress
* does not authorize its products for use as critical components in life-support
* systems where a malfunction or failure may reasonably be expected to result in
* significant injury to the user. The inclusion of Cypress' product in a life-
* support systems application implies that the manufacturer assumes all risk of
* such use and in doing so indemnifies Cypress against all charges. Use may be
* limited by and subject to the applicable Cypress software license agreement.
*******************************************************************************/

/*******************************************************************************
* Included headers
*******************************************************************************/
#include <project.h>
#include <stdbool.h>
#include "ANCS.h"
#include "common.h"


/*******************************************************************************
* Enum for authenticaion and bonding state
*******************************************************************************/
typedef enum
{
    AUTHENTICATION_NOT_CONNECTED,
    AUTHENTICATION_COMPLETE_BONDING_REQD,
    AUTHENTICATION_BONDING_COMPLETE,
    AUTHENTICATION_BONDING_REMOVE_WAITING_EVENT,
    AUTHENTICATION_BONDING_REMOVE_GO_AHEAD
} AUTHENTICATION_STATE;


/*******************************************************************************
* Global variables
*******************************************************************************/
bool enterHibernateFlag = false;
AUTHENTICATION_STATE authState = AUTHENTICATION_NOT_CONNECTED;


/*******************************************************************************
* Public functions
*******************************************************************************/


/*******************************************************************************
* Function Name: StackEventHandler()
********************************************************************************
* Summary:
* Event handler for the BLE events processing.
*
* Parameters:
* uint32 eventCode: The event to be processed
* void * eventParam: Pointer to hold the additional information associated 
*                    with an event
*
* Return:
* None
*
* Theory:
* The function is responsible for handling the events generated by the stack.
* It first starts advertisement once the stack is initialized. 
* Upon advertisement timeout or disconnect events, this function sets a flag
* to indicate to the main() function that it should enter Hibernate mode.
* 
* Once the device is connected, this function initiates an authentication 
* request. It displays a 6-digit passkey on the UART output on a PC and asks
* the user to enter this key on the iOS device (NP) side.
* Once the authentication is complete, the function starts the discovery 
* procedure to know whether ANCS service is supported by the peer device.
*
* When the automated service discovery is complete, the function starts a manual
* discovery procedure for the ANCS service (since the BLE component does not 
* handle discovery of custom services yet - that will be added as part of 
* Creator 3.2).
*
* When the automated service discovery is complete and the ANCS service is not 
* found, the function subscribes to the Service Changed characteristic 
* indication to know if and when the iOS device adds ANCS support later.
*
* Once the ANCS service is found and a new GATT Notification comes for any of 
* the ANCS characteristic, it calls the corresponding function in ANCS.c.
*
*******************************************************************************/
void StackEventHandler(uint32 eventCode, void * eventParam)
{
    CYBLE_GATTC_HANDLE_VALUE_NTF_PARAM_T * handleValueNotification;
    
    switch(eventCode)
    {
        case CYBLE_EVT_STACK_ON:
            /* Minor change in ADV packet for service solicitation */
            cyBle_discoveryData.advData[10] = 0x15;
            
            /* Start advertisement after stack is initialized */
            UART_UartPutString("\n\rAdvertising.");
            CyBle_GappStartAdvertisement(CYBLE_ADVERTISING_FAST);
            break;

            
        case CYBLE_EVT_GAPP_ADVERTISEMENT_START_STOP:
            if(authState != AUTHENTICATION_BONDING_REMOVE_WAITING_EVENT)
            {
                if(CyBle_GetState() == CYBLE_STATE_DISCONNECTED)
                {
                    UART_UartPutString("\n\rAdvertisement timed out. ");
                    UART_UartPutString("Going to Hibernate mode.");
                    
                    /* Enter hibernate mode upon advertisement timeout */
                    enterHibernateFlag = true;
                }
            }
            else
            {
                UART_UartPutString("\n\rAdvertisement stopped. ");
                authState = AUTHENTICATION_BONDING_REMOVE_GO_AHEAD;
            }
            break;
            
            
        case CYBLE_EVT_GAP_DEVICE_DISCONNECTED:
            /* Enter Hibernate mode upon disconnect 
             * Previous state is erased.
             */
            if(authState != AUTHENTICATION_BONDING_REMOVE_WAITING_EVENT)
            {
                UART_UartPutString("\n\rDisconnected. Going to Hibernate mode.");
//                enterHibernateFlag = true;
            }
            else
            {
                UART_UartPutString("\n\rDisconnected. ");
                authState = AUTHENTICATION_BONDING_REMOVE_GO_AHEAD;
            }
            Ancs_Reset();
            CyBle_GappStartAdvertisement(CYBLE_ADVERTISING_FAST);
            
            break;
            
            
        case CYBLE_EVT_GAP_DEVICE_CONNECTED:
            UART_UartPutString("\n\rConnected to a peer device.");
            
            /* Send authentication request upon connection */
            CyBle_GapAuthReq(cyBle_connHandle.bdHandle, &cyBle_authInfo);
            break;
            
            
        case CYBLE_EVT_GAP_PASSKEY_DISPLAY_REQUEST:
            UART_UartPutString("\n\rEnter this passkey in your iPhone: ");
            UART_UartPutChar(HexToDecimal(*(uint32 *)eventParam, 5));
            UART_UartPutChar(HexToDecimal(*(uint32 *)eventParam, 4));
            UART_UartPutChar(HexToDecimal(*(uint32 *)eventParam, 3));
            UART_UartPutChar(HexToDecimal(*(uint32 *)eventParam, 2));
            UART_UartPutChar(HexToDecimal(*(uint32 *)eventParam, 1));
            UART_UartPutChar(HexToDecimal(*(uint32 *)eventParam, 0));
            break;
            
            
        case CYBLE_EVT_GAP_AUTH_COMPLETE:
            /* Authentication complete; initiate service discovery procedure */
            UART_UartPutString("\n\rAuthentication complete. ");
            authState = AUTHENTICATION_COMPLETE_BONDING_REQD;
            CyBle_GattcStartDiscovery(cyBle_connHandle);
            break;
            
            
        case CYBLE_EVT_GAP_AUTH_FAILED:
            /* Authentication failed; enter Hibernate mode */
            UART_UartPutString("\n\rAuthentication failed. Going to Hibernate mode.");
            enterHibernateFlag = true;

            /* Update authentication state so that bond information could be 
             * removed later.
             */
            authState = AUTHENTICATION_BONDING_COMPLETE;
            break;
            
            
        case CYBLE_EVT_GATTC_INDICATION:
            /* Server's services changed; restart service discovery */
            UART_UartPutString("\n\rService changed indication. Redo service discovery.");
            Ancs_Reset();
            CyBle_GattcStartDiscovery(cyBle_connHandle);
            break;
            
            
        case CYBLE_EVT_GATTC_DISCOVERY_COMPLETE:
            /* Automatic discovery does not cover discovery of service snd
             * characteristics with custom 128-bit UUIDs. This has to be done
             * manually. The Read by Group response for Service discovery covers
             * the ANCS custom service. For the ANCS service characteristics, the
             * Read by Type Request has to be sent by the application.
             */
            if(ANCS_DISC_SERVICE_DISCOVERED == ancsDiscoveryStatus)
            {
                CyBle_GattcDiscoverAllCharacteristics(cyBle_connHandle, ancsServiceRange);
            }
            else if(ANCS_DISC_NONE_DISCOVERED == ancsDiscoveryStatus)
            {
                UART_UartPutString("\n\rANCS service not found. ");
                
                /* Service discovery procedure complete; subscribe to the GATT
                 * Service changed indication by writing 0x02 to its CCCD.
                 */
                if((serviceChangedCccdWriteStatus == SERVICE_CHANGED_CCCD_WRITE_REQ_NOT_SENT) && 
                  (cyBle_gattc.serviceChanged.valueHandle != CYBLE_GATT_INVALID_ATTR_HANDLE_VALUE))
                {
                    serviceChangedCccdPacket.value = cccdIndFlagSetStruct;
                    serviceChangedCccdPacket.attrHandle = cyBle_gattc.cccdHandle;
                    CyBle_GattcWriteCharacteristicDescriptors(cyBle_connHandle, &serviceChangedCccdPacket);
                }
                
                /* Internal state machine tracking the CCCD status */
                serviceChangedCccdWriteStatus = SERVICE_CHANGED_CCCD_WRITE_REQ_SENT;
            }
            else
            {
                /* Other conditions need not be handled; they are handled
                 * in the event handler in ANCS.c.
                 */
            }
            break;
            
            
        case CYBLE_EVT_GATTC_READ_BY_GROUP_TYPE_RSP:
        case CYBLE_EVT_GATTC_READ_BY_TYPE_RSP:
        case CYBLE_EVT_GATTC_FIND_INFO_RSP:
        case CYBLE_EVT_GATTC_WRITE_RSP:
        case CYBLE_EVT_GATTC_ERROR_RSP:
            /* See if the events are for ANCS */
            Ancs_EventHandler(eventCode, eventParam);
            break;
            
            
        case CYBLE_EVT_GATTC_HANDLE_VALUE_NTF:
            /* See if the notification packet is for any ANCS characteristic */
            handleValueNotification = (CYBLE_GATTC_HANDLE_VALUE_NTF_PARAM_T *)eventParam;
            if(handleValueNotification->handleValPair.attrHandle == ancsNotifSourceCharHandle)
            {
                /* Notification source characteristic has a new notification */
                Ancs_HandleNotifications(handleValueNotification->handleValPair.value.val);
            }
            else if(handleValueNotification->handleValPair.attrHandle == ancsDataSourceCharHandle)
            {
                /* Data source characteristic has a new notification */
                Ancs_HandleData(handleValueNotification->handleValPair.value.val);
            }
            else
            {
                /* Some other characteristic notification; ignore */
            }
            break;
            
            
        default: 
            break;
    }
}


/*******************************************************************************
* Function Name: BondingImplementation()
********************************************************************************
* Summary:
* Implements bonding of peer BLE device information.
*
* Parameters:
* None
*
* Return:
* None
*
* Theory:
* The function stores the peer BLE device information to flash (called bonding)
* when the device is ready. When the user wants to clear the bond information, 
* it is cleared in this function.
*
*******************************************************************************/
static void BondingImplementation(void)
{
    uint8 command;
    CYBLE_GAP_BD_ADDR_T clearAllDevices = {{0,0,0,0,0,0},0};
    
    switch(authState)
    {
        case AUTHENTICATION_COMPLETE_BONDING_REQD:
            /* Store bonding data of the current connection */
            while(CYBLE_ERROR_OK != CyBle_StoreBondingData(1));
            
            authState = AUTHENTICATION_BONDING_COMPLETE;
            UART_UartPutString("Bonding complete. ");
            break;
            
            
        case AUTHENTICATION_BONDING_COMPLETE:
            /* See if the user pressed 'R' button to clear the bond list. */
            command = UART_UartGetChar();
            
            if(command != 0u)
            {
                if((command == 'r') || (command == 'R'))
                {
                    /* User wants the bond to be removed */
                    UART_UartPutString("\n\rClear the bond list. ");
                    if(CyBle_GetState() == CYBLE_STATE_CONNECTED)
                    {
                        /* Disconnect */
                        authState = AUTHENTICATION_BONDING_REMOVE_WAITING_EVENT;
                        CyBle_GapDisconnect(cyBle_connHandle.bdHandle);
                    }
                    else if(CyBle_GetState() == CYBLE_STATE_ADVERTISING)
                    {
                        /* Stop advertisement */
                        authState = AUTHENTICATION_BONDING_REMOVE_WAITING_EVENT;
                        CyBle_GappStopAdvertisement();
                    }
                    else
                    {
                        authState = AUTHENTICATION_BONDING_REMOVE_GO_AHEAD;
                    }
                }
            }
            break;
            
            
        case AUTHENTICATION_BONDING_REMOVE_GO_AHEAD:
            /* Remove all bonded devices in the list */
            CyBle_GapRemoveDeviceFromWhiteList(&clearAllDevices);
            
            while(CYBLE_ERROR_OK != CyBle_StoreBondingData(1));
            UART_UartPutString("Cleared the list of bonded devices. \n\n\r");
                
            authState = AUTHENTICATION_NOT_CONNECTED;
            
            /* Start advertisement again */
            UART_UartPutString("Advertising. ");
            CyBle_GappStartAdvertisement(CYBLE_ADVERTISING_FAST);
            break;
            
            
        default:
            break;
    }
}


/*******************************************************************************
* Function Name: LowPowerImplementation()
********************************************************************************
* Summary:
* Implements low power in the project.
*
* Parameters:
* None
*
* Return:
* None
*
* Theory:
* The function tries to enter deep sleep as much as possible - whenever the 
* BLE is idle and the UART transmission/reception is not happening. At all other
* times, the function tries to enter CPU sleep.
*
*******************************************************************************/
static void LowPowerImplementation(void)
{
    CYBLE_LP_MODE_T bleMode;
    uint8 interruptStatus;
    
    /* For advertising and connected states, implement deep sleep 
     * functionality to achieve low power in the system. For more details
     * on the low power implementation, refer to the Low Power Application 
     * Note.
     */
    if((CyBle_GetState() == CYBLE_STATE_ADVERTISING) || 
       (CyBle_GetState() == CYBLE_STATE_CONNECTED))
    {
        bleMode = CyBle_EnterLPM(CYBLE_BLESS_DEEPSLEEP);
        interruptStatus = CyEnterCriticalSection();
        if(bleMode == CYBLE_BLESS_DEEPSLEEP)
        {
            if((CyBle_GetBleSsState() == CYBLE_BLESS_STATE_ECO_ON) || 
               (CyBle_GetBleSsState() == CYBLE_BLESS_STATE_DEEPSLEEP))
            {
                /* Deep sleep only if UART completes transfer and we
                 * are not waiting for the user to enter anything.
                 */
                if(((UART_SpiUartGetTxBufferSize() + UART_GET_TX_FIFO_SR_VALID) == 0u) && 
                   (ancsUsageState != ANCS_USAGE_INCOMING_CALL_WAITING_FOR_INPUT))
                {
                    CySysPmDeepSleep();
                }
                else
                {
                    CySysPmSleep();
                }
            }
        }
        else
        {
            if(CyBle_GetBleSsState() != CYBLE_BLESS_STATE_EVENT_CLOSE)
            {
                CySysPmSleep();
            }
        }
        CyExitCriticalSection(interruptStatus);
    }
}


/*******************************************************************************
* Function Name: main()
********************************************************************************
* Summary:
* Main function for the project.
*
* Parameters:
* None
*
* Return:
* None
*
* Theory:
* The function starts BLE and UART components.
* This function process all BLE events and also implements the low power 
* functionality - both deep sleep and hibernate.
*
*******************************************************************************/
int main()
{
    CYBLE_GAP_BONDED_DEV_ADDR_LIST_T bondedDeviceList;
    
    /* Enable global interrupts */
    CyGlobalIntEnable; 

    /* Start a new UART session and clear screen */
    UART_Start();
    UART_UartPutChar(12);
    UART_UartPutString("=====ANCS Demo=====\n\r");
    UART_UartPutString("\n\rPress 'R' at any time to clear the bonded device list. \n\r");
    
    /* Initialize BLE component and ANCS related information */
    CyBle_Start(StackEventHandler);
    Ancs_Reset();
    
    /* Check whether we already have anything in the bonded device list */
    CyBle_GapGetBondedDevicesList(&bondedDeviceList);
    if(bondedDeviceList.count != 0)
    {
        authState = AUTHENTICATION_BONDING_COMPLETE;
    }
    
    /* Custom service discovery is not implemented in the component yet. 
     * So we need to enable all the events to come to the application 
     * in order to process raw data for ANCS service discovery.
     */
    cyBle_eventHandlerFlag |= CYBLE_ENABLE_ALL_EVENTS;
    
    /* Inifinite loop */
    for(;;)
    {
        /* Process all the generated events. This includes the general events
         * for BLE initialization, advertisement, connection etc. It also 
         * includes the events for service discovery and ANCS notifications.
         */
        CyBle_ProcessEvents();

        /* Handle the state machine for ANCS notifications */
        Ancs_StateMachine();

        /* Handle bonding of device information*/
        BondingImplementation();
        
        /* To achieve low power in the device */
        LowPowerImplementation();
        
        /* Enter hibernate mode when necessary. */
        if(enterHibernateFlag == true)
        {
            WakeupPin_ClearInterrupt();
            WakeupPinInterrupt_Start();
            
            /* Wait for the UART to complete transfer */
            while((UART_SpiUartGetTxBufferSize() + UART_GET_TX_FIFO_SR_VALID) != 0u);
            
            CySysPmHibernate();
        }
    }
}

/* [] END OF FILE */
